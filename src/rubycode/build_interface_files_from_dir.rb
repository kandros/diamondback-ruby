#!/opt/local/bin/ruby

# == Description
#
# converts type annotations generated by type_prof.rb into interface files
# that can be consumed by DRuby
#
# == Usage
# 
# Required parameters:
#  --output           path to directory in which to write interface files
#
#  --annotation_path  path to directory containing annotation data
#                     produced by type_prof.rb
#

class AnnotationTree
  NO_MODULE = "__EMPTY_MOD__"
  NO_CLASS = "__NO_CLASS__"

  SIGNATURE = <<"  ENDSIG"
# DRuby stdlib interface files
# Automatically generated by #{$0}
# #{Time.now()}

  ENDSIG
  def initialize
    @a = Hash.new
  end

  # use a simple nested hash tree to find unique annotations
  # module -> class -> method -> signature
  # (file/line currently ignored)
  def add(file, line, clazz, method, signature)
    mod = NO_MODULE
    if(clazz.match(/([\w\d]+)::([\w\d]+)/))
      mod, clazz = $1, $2
    end

    if(!@a.has_key?(mod))
      @a[mod] = {}
    end
    m = @a[mod]
    if(!m.has_key?(clazz))
      m[clazz] = {}
    end
    c = m[clazz]
    if(!c.has_key?(method))
      c[method] = {}
    end
    s = c[method]
    if(!s.has_key?(signature))
      s[signature] = true
    end
  end

  # do the same thing, but for module functions, which need to be
  # annotated differently
  def add_module_function(file, line, mod, method, signature)
    clazz = NO_CLASS
    if(!@a.has_key?(mod))
      @a[mod] = {}
    end
    m = @a[mod]

    if(!m.has_key?(clazz))
      m[clazz] = {}
    end
    c = m[clazz]

    if(!c.has_key?(method))
      c[method] = {}
    end
    s = c[method]

    if(!s.has_key?(signature))
      s[signature] = true
    end

  end

  # write out tree in sorted top-level class/module order
  def dump_class_file(base_path)
    @a.keys.sort.each {|mod|
      clazzes = @a[mod]
      depth = 0

      output_file = nil

      # write outer module wrapper if one is needed
      if(mod != NO_MODULE)
        fresh_file = false
        path = File.join(base_path, mod + ".rbi")
        fresh_file = true if(!File.exists?(path))
        output_file = open(path, "a")
        output_file.puts SIGNATURE if fresh_file
        output_file.puts((' ' * depth ) + "module #{mod}")
        depth += 2
      end

      # write outer class wrapper if one is needed
      # NOTE: this assumes that modules strictly contain classes, but
      # sometimes this is not true!  (Certain libraries have modules
      # inside top-level classes.)  You'll need to find and fix these
      # by hand if any of these cases occur.
      clazzes.sort.each {|clazz, methods|
        if(mod == NO_MODULE)
          if(output_file != nil)
            $stderr.puts "WARNING:  opening per-class rbi file " +
              "when module file exists?"
            output_file.close
            output_file = nil
          end

          fresh_file = false
          path = File.join(base_path, clazz + ".rbi")
          fresh_file = true if(!File.exists?(path))
          output_file = output_file = open(path, "a")
          output_file.puts SIGNATURE if fresh_file
        end

        if(clazz != NO_CLASS)
          output_file.puts((' ' * depth ) + "class #{clazz}")
          depth += 2
        end

        # write unique signatures for each method belonging
        # to this class; if this is a module method, handle
        # it specially
        last_was_in_metaclass = false
        methods.keys.sort.each {|name|

          sigs = methods[name]
          max_sig = nil
          in_metaclass = false
          druby_name = name

          if(name.match(/^~?self\./))
            druby_name = name.sub(/^~?self\./, "")

            if(!druby_name.match(/^[A-Za-z_0-9]+/))
              druby_name = '"' + druby_name + '"'
            end

            in_metaclass = true

          else
            if(!druby_name.match(/^[A-Za-z_0-9]+/))
              druby_name = '"' + druby_name + '"'
            end

          end

          if(in_metaclass && !last_was_in_metaclass)
            output_file.puts((' ' * depth ) + "metaclass\n")
            depth += 2
          end

          if(!in_metaclass && last_was_in_metaclass)
            depth -= 2
            output_file.puts((' ' * depth) + "end # metaclass\n")
          end

          sigs.keys.sort.each {|sig|
            # skip garbage types
            next if(sig.match(/#<Class:0x[0-9a-f]+>/))
            output_file.puts((' ' * depth ) + "#{druby_name} : #{sig}")

            if(sig.match(/\(([\w\d_,:.<>{}! ]*)\) ->/))
              arg_list = $1.split(/,\s*/)
              if(max_sig == nil ||
                 arg_list.length > max_sig.length)
                max_sig = arg_list
              end

            else
              raise "Bad signature: #{sig}"
            end

          }
          last_was_in_metaclass = in_metaclass

        }

        if(last_was_in_metaclass)
          depth -= 2
          output_file.puts((' ' * depth) + "end # metaclass\n")
        end

        if(clazz != NO_CLASS)
          depth -= 2
          output_file.puts((' ' * depth ) + "end # class #{clazz}")
          output_file.puts ""
        end

        if(mod == NO_MODULE)
          if(output_file == nil)
            $stderr.puts "WARNING:  output rbi file " +
              "for class #{clazz} is closed!"

          else
            output_file.close
            output_file = nil

          end
        end
      }

      if(mod != NO_MODULE)
        depth -=2
        output_file.puts "end # module #{mod}"
        output_file.puts ""

        if(output_file == nil)
          $stderr.puts "WARNING:  output rbi file " +
            "for module #{mod} is closed!"
        else
          output_file.close
          output_file = nil
        end

      end
    }
  end
end

def process_base_types(base, path)
  #TODO:  this seems to be broken.  consider fixing it if we ever want to use it

  pfh = open(path, "r")
  fail "Can't open base types at '${path}': #{$!}" if pfh == nil

  output_file = nil
  depth = 0

  scope = []

  pfh.each_line {|line|
    line.chomp!("\n")
    next if(line =~ /^\s*def [a-zA-Z_.]+.* end(?:\s*#.*)?$/);
    if((mdata = line.match(
      /^\s*(class|module)\s*(:?<<)?\s*(?:([a-zA-Z0-9_.:]+)(?:\s*<\s*[a-zA-Z0-9_.:]+)?)((?:\s*#.*)?)\s*$/ \
      )) != nil)
      
      classname = mdata[3]
      orig_classname = classname.clone
      classname.gsub!(/::.*$/, "")

      scope.push(classname)

      if(depth == 0)
        fname = File.join(base, classname + ".rbi")

        output_file = open(fname, "a") if(depth == 0)
      end

      depth += 1

    end

    line.gsub!(/##% /, "") if(line =~ /^\s*##%/)

    if(output_file)
      if(depth > 0 || line =~ /^\s*$/)
        output_file.puts line
      end
    end

    if(line =~ /^\s*end$/)
      depth -= 1
      if(depth == 0)
        output_file.close
        output_file = nil
      end
    end
  }

end

#========================================

require 'getoptlong'
require 'rdoc/usage'

params =
  [
   ['--help', '-h', GetoptLong::NO_ARGUMENT],
   ['--output', '-o', GetoptLong::REQUIRED_ARGUMENT],
   ['--annotation_path', '-a', GetoptLong::REQUIRED_ARGUMENT],
   #['--base_types', '-b', GetoptLong::REQUIRED_ARGUMENT],
  ]

opts = GetoptLong.new(*params)

output_path = nil
annot_dir = nil
base_types = nil

opts.each {|param, arg|
  case param
  when '--help'
    RDoc::usage
  when '--output'
    output_path = arg
  when '--annotation_path'
    annot_dir = arg
  when '--base_types'
    base_types = arg
  end
}

required_params = {
  'output' => output_path,
  'annotation_path' => annot_dir,
}
missing_options = required_params.select {|k, v| v == nil}
if(missing_options.length > 0)
  puts "missing option%s: %s" % [missing_options.length > 1 ? "s" : "",
                                 missing_options.map {|x| x[0]}.join(", ")]
  RDoc::usage
end

unless(File.directory?(annot_dir))
  puts "Path to annotation data '#{annot_dir}' is not a directory: #{$!}"
  RDoc::usage
end

unless(File.directory?(output_path))
  puts "Output directory '#{output_path}' does not exist -- creating"
  Dir.mkdir(output_path)
end

# TODO:  do we generate or not generate annotations for base types?
# NOTE:  this doesn't seem to work just yet, but that's okay -- we probably
# don't want to use it
if(base_types != nil)
  if(!File.file?(base_types))
    puts "Path to base types '#{base_types}' is not a file: #{$!}"
    RDoc::usage
  end
  process_base_types(output_path, base_types)
end

d = Dir.open(annot_dir)
fail "Cannot open directory #{annot_dir}: #{$!}" unless d

at = AnnotationTree.new()

d.each {|fname|
  next if fname =~ /^\.\.?$/

  path = File.join(annot_dir, fname)
  annot_fh = open(path, "r")

  # parse generated annotation data
  annot_fh.each_line {|line|
    line.strip!
    if((match = line.match( \
        /^\[(.*)@(\d+)\] ##% \(module\) ([\w\d_:.]+)\.(.+) : (.*)$/) \
        ) != nil)
      m = match.captures
      file = m.shift
      line = m.shift
      mod = m.shift
      method = m.shift
      signature = m.shift
      at.add_module_function(file, line, mod, method, signature)    

    elsif((match = line.match( \
           /^\[(.*)@(\d+)\] ##% ([\w\d_:]+):(.+) : (.*)$/)) != nil)
      m = match.captures
      file = m.shift
      line = m.shift
      clazz = m.shift
      method = m.shift

      # trick to put metaclass methods last in sort order
      method.sub!(/^self/, "~self")
      signature = m.shift
      at.add(file, line, clazz, method, signature)

    elsif(line.match(/-----STOP-----/))
      break

    elsif(line != "")
      # ignore bad lines for now, they might just be comments in input data
    end
  }
}

# dump processed annotation data
at.dump_class_file(output_path)

#========================================
