open OUnit
open Cfg.Abbr
open Cfg_test_helper
open Config

let raw_cfg_test (desc,iface,cfg) =
  conf.error_raises_exc <- true;
  desc ^ ": " ^ iface >::
    (fun () ->
      let iface = TypeAnnotParser.interface_file TypeAnnotLexer.token (Lexing.from_string iface) in
      let iface_cfg = Cfg.stmt_of_interface iface in
        assert_cfg_equal iface_cfg cfg
    )

let parsed_cfg_test (desc,iface,ruby) =
  Cfg_refactor.re_init ();
  let cfg = Cfg_refactor.refactor_ast (Parse_helper.parse_ruby_string ruby) in
  raw_cfg_test (desc,iface,cfg)

(* Compare cfg generated by stmt_of_interface to a hand-coded cfg *)
let iface_to_raw_cfg_tests = [
  ( "Single Require",
    "require \"foo\"",
    seq [(call "require" [str "foo"] dp)] dp
  );

  ( "Two require statements",
    "require \"foo\" require \"bar\"",
    seq [(call "require" [str "foo"] dp);
         (call "require" [str "bar"] dp)] dp
  );

(* 
  ( "Class Definition",
    "class A end",
    seq [(nameclass )] dp
  );
*)
]

(* Compare cfg generated by stmt_of_interface to a cfg
 * generated by parsed ruby code. *)
let iface_to_parsed_cfg_tests = [
  ("Single Require",
   "require \"foo\"",
   "require \"foo\""
  );

  ("Single Class Definition",
   "class A end",
   "##% A \n class A; end"
  );
 
]

let (@@) = List.rev_append

let suite = "Interface suite" >:::
   (List.map raw_cfg_test iface_to_raw_cfg_tests) @@
   (List.map parsed_cfg_test iface_to_parsed_cfg_tests)
  
